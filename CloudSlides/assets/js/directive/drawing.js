// Generated by CoffeeScript 1.7.1
(function() {
  angular.module('drawing', []).directive("drawing", function($rootScope) {
    return {
      restrict: "A",
      link: function(scope, element, attrs) {
        var ctx, draw, drawing, isEnableDrawing, lastX, lastY, lineColorCode, linePath, lineWidth, onDown, onMove, onUp, reset, scaleRate;
        reset = function() {
          element[0].width = element[0].width;
        };
        ctx = element[0].getContext("2d");
        drawing = false;
        lastX = void 0;
        lastY = void 0;
        linePath = [];
        scaleRate = 1;
        isEnableDrawing = void 0;
        lineColorCode = void 0;
        lineWidth = void 0;
        draw = function(lX, lY, cX, cY, color, width) {
          if (color == null) {
            color = "#4bf";
          }
          if (width == null) {
            width = 5;
          }
          ctx.moveTo(lX / scaleRate, lY / scaleRate);
          ctx.lineTo(cX / scaleRate, cY / scaleRate);
          ctx.strokeStyle = color;
          ctx.lineWidth = width;
          ctx.stroke();
        };
        scope.$on('canvas_scale_rate_changed', function(event, newScaleRate) {
          return scaleRate = newScaleRate;
        });
        scope.$on('change_is_enabledrawing', function(event, newIsEnableDrawing) {
          return isEnableDrawing = newIsEnableDrawing;
        });
        scope.$on('change_line_color', function(event, newLineColorCode) {
          return lineColorCode = newLineColorCode;
        });
        scope.$on('change_line_width', function(event, newLineWidth) {
          return lineWidth = newLineWidth;
        });
        onDown = function(event) {
          if (!isEnableDrawing) {
            return;
          }
          lastX = event.offsetX;
          lastY = event.offsetY;
          ctx.beginPath();
          drawing = true;
          return linePath = [lastX, lastY];
        };
        onMove = function(event) {
          var currentX, currentY;
          if (drawing) {
            if (event.offsetX !== undefined) {
              currentX = event.offsetX;
              currentY = event.offsetY;
            } else {
              currentX = event.layerX - event.currentTarget.offsetLeft;
              currentY = event.layerY - event.currentTarget.offsetTop;
            }
            draw(lastX, lastY, currentX, currentY, lineColorCode, lineWidth);
            linePath.push(currentX - lastX, currentY - lastY);
            lastX = currentX;
            return lastY = currentY;
          }
        };
        onUp = function(event) {
          var i, line, newPath, _fn, _i, _ref;
          drawing = false;
          newPath = [];
          _fn = function(i) {
            return newPath.push(linePath[i] / scaleRate);
          };
          for (i = _i = 0, _ref = linePath.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
            _fn(i);
          }
          line = {
            path: newPath,
            color: lineColorCode,
            width: lineWidth
          };
          return $rootScope.$broadcast('draw_line', line);
        };
        element.bind("mousedown", function(event) {
          onDown(event);
        });
        element.bind("mousemove", function(event) {
          onMove(event);
        });
        element.bind("mouseup", function(event) {
          onUp(event);
        });
      }
    };
  });

}).call(this);

//# sourceMappingURL=drawing.map
